<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: IPC | Amyangfei's Blog]]></title>
  <link href="http://amyangfei.me/blog/categories/ipc/atom.xml" rel="self"/>
  <link href="http://amyangfei.me/"/>
  <updated>2014-03-04T21:28:28+08:00</updated>
  <id>http://amyangfei.me/</id>
  <author>
    <name><![CDATA[amyangfei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[bash subshell变量作用域问题]]></title>
    <link href="http://amyangfei.me/2013/01/07/abtest-script-and-bash-subshell/"/>
    <updated>2013-01-07T00:00:00+08:00</updated>
    <id>http://amyangfei.me/2013/01/07/abtest-script-and-bash-subshell</id>
    <content type="html"><![CDATA[<p>今天研究apache ab这个测试工具，在网上看到<a href="http://blog.csdn.net/chosen0ne/article/details/7302991" target="_blank">压力测试shell脚本</a>一文介绍了一个封装的bash脚本，用于多次测试返回requests per second的平均值，对脚本进行了简单的改写，将所有的测试输出进行记录。改写脚本在文章的最后。</p>

<p>改写过程中发现这样一个问题，比如写下面的脚本：</p>

<p>``` bash</p>

<h1>!/bin/bash</h1>

<p>result=&ldquo;&rdquo;
cat abtest_temp.log | while read LINE
do</p>

<pre><code>result=`echo $LINE | grep 'Requests per second:'`
if [ "$result" != "" ]
then
    break
fi
</code></pre>

<p>done
echo &ldquo;result is &rdquo;${result}
```</p>

<!-- more -->


<p>在读取abtest_temp.log文件内容后，result的值仍为空，这是因为bash遇到管道后会创建一个新的进程，于是result是subshell中的局域变量，subshell对变量的修改不会影响原shell中的变量。</p>

<p>subshell可以export父shell中的变量，但export出来的变量只是父shell中变量的一个拷贝，进行修改并不能影响到父shell。但反过来，父shell再次更改此变量时，subshell 再去读时，读到的是新值，而不是原来的值。参考bash man page中的说明：<a href="http://www.gnu.org/software/bash/manual/bashref.html#Pipelines" target="_blank">Each command in a pipeline is executed in its own subshell</a>以及<a href="http://linux.die.net/man/1/bash" target="_blank">Each command in a pipeline is executed as a separate process (i.e., in a subshell).</a></p>

<p>对于这种情形有一些解决方法，这里给出两种：第一种是将subshell外需要访问的变量输出到临时文件中。第二种是使用命名管道。本质都是进程间通信的实现。</p>

<h3>使用临时文件</h3>

<p>``` bash</p>

<h1>!/bin/bash</h1>

<p>result=&ldquo;&rdquo;
cat abtest_temp.log | while read LINE
do</p>

<pre><code>result=`echo $LINE | grep 'Requests per second:'`
if [ "$result" != "" ]
then
    echo $result &gt; .result_temp
    break
fi
</code></pre>

<p>done
echo &ldquo;result is &rdquo;<code>cat .result_temp</code>
```</p>

<h3>使用命名管道</h3>

<p>``` bash</p>

<h1>!/bin/bash</h1>

<p>result=&ldquo;&rdquo;
mkfifo pipetem
(cat abtest_temp.log | while read LINE
do</p>

<pre><code>result=`echo $LINE | grep 'Requests per second:'`
if [ "$result" != "" ]
then
    echo $result &gt; pipetem &amp; 
    break
fi
</code></pre>

<p>done)
read result &lt; pipetem
rm pipetem
echo &ldquo;result is &rdquo;${result}</p>

<p>```</p>

<h3>对apache ab封装的测试脚本</h3>

<p>``` bash</p>

<h1>!/bin/bash</h1>

<p>total_request=1000
concurrency=100
times=1</p>

<p>cmd_idx=1
param_count=$#
while [ $cmd_idx -lt $param_count ]
do</p>

<pre><code>cmd=$1
shift 1 #remove $1
case $cmd in
    -n)
        total_request=$1
        shift 1;;
    -c)
        concurrency=$1
        shift 1;;
    -t)
        times=$1
        shift 1;;
    *)
        echo "$cmd, support parameter: -n, -c, -t";;
esac
cmd_idx=`expr $cmd_idx + 2` 
</code></pre>

<p>done</p>

<p>url=$1
if [ $url = &lsquo;&rsquo; ]; then</p>

<pre><code>echo 'the test url must be provided...'
exit 2
</code></pre>

<p>fi</p>

<p>echo &ldquo;Total Request: $total_request, Concurrency: $concurrency, URL: $url, Times: $times&rdquo;</p>

<p>ab_dir=/usr/bin
ab_cmd=&ldquo;$ab_dir/ab -n $total_request -c $concurrency $url&rdquo;</p>

<p>echo $ab_cmd
idx=1
rps_sum=0
max=-1
min=99999999
while [ $idx -le $times ]
do</p>

<pre><code>echo "start loop $idx"
$ab_cmd &gt;abtest_temp.log 2&gt;&amp;1
cat abtest_temp.log | while read LINE 
do
    result=`echo $LINE | grep 'Requests per second:'`
    if [ "$result" != "" ]
    then
        echo $result &gt; .result_temp
        break
    fi
done
result=`cat .result_temp`
rm .result_temp
result=`echo $result | awk -F ' ' '{ print $4 }' | awk -F '.' '{ print $1 }'`
rps_sum=`expr $result + $rps_sum`
if [ $result -gt $max ]; then
    max=$result
fi
if [ $result -lt $min ]; then
    min=$result
fi
idx=`expr $idx + 1`
</code></pre>

<p>done
echo &ldquo;avg rps: &rdquo;<code>expr $rps_sum / $times</code>
echo &ldquo;min rps: $min&rdquo;
echo &ldquo;max rps: $max&rdquo;
```</p>

<h3>参考文章</h3>

<p><a href="http://blog.csdn.net/chosen0ne/article/details/7302991" target="_blank">压力测试shell脚本</a>，<a href="http://blog.csdn.net/sosodream/article/details/5683515" target="_blank">实例解析shell子进程（subshell )</a>，<a href="http://lihdd.net/bash-pipe-pitfall" target="_blank">小心bash的管道</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Named Pipes to Communicate Between Processes]]></title>
    <link href="http://amyangfei.me/2012/03/21/namedpipe-communication/"/>
    <updated>2012-03-21T00:00:00+08:00</updated>
    <id>http://amyangfei.me/2012/03/21/namedpipe-communication</id>
    <content type="html"><![CDATA[<p>最近几天生活突然变得异常纠结，许多乱乱的事情搅在了一起，真希望可以快到斩乱麻似的解决问题，可到头来每一件事情都还是要小心翼翼地处理。</p>

<p>犹豫了好久终于决定向创新工场辞职，实习毕设兼顾的日子有些让我心力交瘁。昨天搭博客还出了问题，虽是粗心大意，可确实做了不正确的事，满心愧疚。毕设要和研究生学长合作完成，学长在没和我有过任何商量的情况下选择了.NET的开发平台，一来我对微软的产品不感兴趣，没有过什么写C#的经验，二来需要继续使用的原有系统是C++开发的，就不得不考虑在C#中调用C++的方法和类。百味俱陈，无限纠结，心情一落千丈。</p>

<p>虽说如此，毕设还要做。现有的需求是将一个由C++实现的SQL语法，语义解析器迁移到C#工程中进一步进行开发。网上查了一些，有利用DllImport，有托管C++包装现有的DLL供C#调用的方法，还有一些包装C++的方法，简单看了一下一头雾水，考虑到项目的特殊性，最后没有选择C#调用C++的方式，而是采取了进程间通信的方法。</p>

<!-- more -->


<p>具体实现是在C++的SQL语义解析器端开启一个服务进程，等待客户端的连接请求。每次C#端发起连接，在C++端开启一个线程，进行相应的语法，语义解析最后按定义好的数据结构给客户端返回结果。进程间通信使用了Named Pipe。我在<a href="http://msdn.microsoft.com/en-us/library/bb762927.aspx" target="_blank">MSDN</a>官方文档上看到了一个很详细的使用方法，基本是按照官方文档实现的。</p>

<p>这里列出我觉得比较重要的部分，在这里有一份MSDN>提供的完整的<a href="http://msdn.microsoft.com/en-us/library/aa365588(VS.85).aspx" target="_blank">C++ Server</a>的代码</p>

<h3>C++ Server</h3>

<p>``` c++
hPipe = CreateNamedPipe(lpszPipename, PIPE_ACCESS_DUPLEX,</p>

<pre><code>PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, 0, NULL);
</code></pre>

<p>fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);</p>

<p>if (fConnected) {</p>

<pre><code>printf("Client connected, creating a processing thread.\n"); 
// Create a thread for this client. 
hThread = CreateThread(NULL, 0, InstanceThread, (LPVOID) hPipe, 0, &amp;dwThreadId);
if (hThread == NULL) {
    _tprintf(TEXT("CreateThread failed, GLE=%d.\n"), GetLastError()); 
    return -1;
}
else CloseHandle(hThread); 
</code></pre>

<p>}
else</p>

<pre><code>CloseHandle(hPipe); 
</code></pre>

<p>}</p>

<p>DWORD WINAPI InstanceThread(LPVOID lpvParam) {
   HANDLE hHeap      = GetProcessHeap();
   TCHAR<em> pchRequest = (TCHAR</em>)HeapAlloc(hHeap, 0, BUFSIZE<em>sizeof(TCHAR));
   TCHAR</em> pchReply   = (TCHAR<em>)HeapAlloc(hHeap, 0, BUFSIZE</em>sizeof(TCHAR));
   DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0;
   BOOL fSuccess = FALSE;
   HANDLE hPipe  = NULL;
   bool destoryThread = false;</p>

<p>   printf(&ldquo;InstanceThread created, receiving and processing messages.\n&rdquo;);</p>

<p>   hPipe = (HANDLE) lpvParam;
   while (!destoryThread) {</p>

<pre><code>    while(true) {
       fSuccess = ReadFile(hPipe, pchRequest, BUFSIZE * sizeof(TCHAR), &amp;cbBytesRead, NULL);
       if (!fSuccess || cbBytesRead == 0) {
           destoryThread = true;
           break;
       }
       pchRequest[cbBytesRead] = '\0';
       strcpy(pchReply, getParsedSql(pchRequest)); //getParsedSql是调用的接口函数
       cbReplyBytes = (lstrlen(pchReply))*sizeof(TCHAR);
       pchReply[cbReplyBytes] = '\n';
       pchReply[cbReplyBytes+1] = '\0';
       cbReplyBytes += 1;

       fSuccess = WriteFile(hPipe, pchReply, cbReplyBytes, &amp;cbWritten, NULL);//send back to client

       cout &lt;&lt; "Result after sql parse: " &lt;&lt; pchReply &lt;&lt; endl;
       if (!fSuccess || cbReplyBytes != cbWritten) {
           destoryThread = true;
           break;
       }
   }
</code></pre>

<p>  }</p>

<pre><code>//do some clean work
</code></pre>

<p>   printf(&ldquo;InstanceThread exitting.\n&rdquo;);
   return 1;
}
```</p>

<h3>C# Client</h3>

<p>``` c#
static void Main(string[] args) {</p>

<pre><code>NamedPipeClientStream pipeClient = new NamedPipeClientStream(".", "testpipe", 
    PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.Impersonation);

Console.WriteLine("Connecting to server...\n");
pipeClient.Connect(2000);

StreamWriter sw = new StreamWriter(pipeClient);
StreamReader sr = new StreamReader(pipeClient);
sw.AutoFlush = true;
while (true) {
    string outStr = Console.ReadLine();
    sw.WriteLine(outStr);
    if (outStr.Equals("quit")) {
        break;
    }
    Console.WriteLine("get back from server:" + sr.ReadLine());
}
sw.Close();
sr.Close();
pipeClient.Close();
// Give the client process some time to display results before exiting.
Thread.Sleep(4000);
</code></pre>

<p>}
```</p>

<p>今天写代码时候遇到一个bug，就是在服务器接收pchRequest处理得到pchReply后向客户端发送总会发生阻塞，调了很久找到bug的出处是处理后的pchReply末尾没有换行符，导致在C#客户端使用ReadLine()接收一直处于阻塞状态。于是在代码中有了下面的一段。</p>

<p><code>c++
cbReplyBytes = (lstrlen(pchReply))*sizeof(TCHAR);
pchReply[cbReplyBytes] = '\n';
pchReply[cbReplyBytes+1] = '\0';
cbReplyBytes += 1;
</code></p>
]]></content>
  </entry>
  
</feed>

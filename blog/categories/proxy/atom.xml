<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: proxy | Amyangfei's Blog]]></title>
  <link href="http://amyangfei.me/blog/categories/proxy/atom.xml" rel="self"/>
  <link href="http://amyangfei.me/"/>
  <updated>2016-08-03T23:18:48+08:00</updated>
  <id>http://amyangfei.me/</id>
  <author>
    <name><![CDATA[amyangfei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SSH through different kinds of proxy]]></title>
    <link href="http://amyangfei.me/2015/01/24/ssh-and-proxy/"/>
    <updated>2015-01-24T00:00:00+08:00</updated>
    <id>http://amyangfei.me/2015/01/24/ssh-and-proxy</id>
    <content type="html"><![CDATA[<p>有时候因为网络、安全等原因，我们不能通过 ssh 直接连接到目标主机，而是需要通过代理服务器或跳板机实现连接。本文总结通过代理或跳板机使用 ssh 的各种方法，并且分析这些方法的基本原理。</p>

<p>我们设定本地主机的地址为 homepc，绑定有公网 ip；运行有各类代理的代理服务器或跳板机地址为 proxy-server，proxy-server 上绑定一个公网 ip，同时绑定一个内网 ip（假定为10.0.10.252）；需要连接的目标主机 target-server，绑定内网 ip（假定为 10.0.10.25）。所有的用户名、登录用户名使用 apple。</p>

<!-- more -->


<p>首先我们介绍一些常见的连接方法</p>

<h3>登录跳板机，在跳板机上连接目标主机</h3>

<hr />

<ul>
<li>方法A：直接登录，可以通过 <code>-A</code> 选项利用Agent forwarding 特性</li>
</ul>


<p>``` bash</p>

<h1>now on homepc</h1>

<p>apple@homepc
➜ ssh -A apple@proxy-server</p>

<h1>now on proxy-server</h1>

<p>apple@proxy-server
➜ ssh <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x61;&#x70;&#x70;&#108;&#101;&#64;&#49;&#x30;&#x2e;&#48;&#46;&#x31;&#48;&#46;&#50;&#x35;">&#x61;&#112;&#x70;&#x6c;&#101;&#x40;&#49;&#x30;&#46;&#x30;&#x2e;&#x31;&#48;&#x2e;&#x32;&#x35;</a></p>

<p>```</p>

<ul>
<li>方法B：A useful trick，通过 <code>-tt</code> 强制分配 tty，直接执行 ssh 命令</li>
</ul>


<p>``` bash</p>

<p>apple@homepc
➜  ssh -A -tt apple@proxy-server ssh <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#97;&#112;&#112;&#108;&#101;&#64;&#49;&#x30;&#46;&#48;&#46;&#x31;&#48;&#46;&#x32;&#x35;">&#97;&#112;&#112;&#108;&#101;&#x40;&#x31;&#x30;&#46;&#x30;&#46;&#x31;&#48;&#46;&#x32;&#x35;</a></p>

<p>```</p>

<ul>
<li>方法C：利用 netcat 在跳板机上建立 tunnel，通过此 tunnel 连接目标主机</li>
</ul>


<p>``` bash</p>

<p>apple@homepc
➜  ssh -oProxyCommand=&lsquo;ssh apple@proxy-server nc %h %p&rsquo; <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#97;&#112;&#112;&#x6c;&#101;&#64;&#49;&#48;&#46;&#48;&#46;&#49;&#48;&#46;&#x32;&#x35;">&#97;&#x70;&#x70;&#x6c;&#x65;&#64;&#49;&#48;&#46;&#x30;&#x2e;&#x31;&#x30;&#x2e;&#50;&#x35;</a></p>

<p>```</p>

<h3>借助 proxy 连接目标主机</h3>

<hr />

<ul>
<li>方法D：本地 ssh 代理，在 proxy-server 上用户 apple 设有 nologin 的 shell 权限，不能通过 ssh 登录 proxy-server 但是可以进行 ssh 连接，通过 <code>-D</code> 进行本地的端口转发，详情可以查看 man ssh。</li>
</ul>


<p>``` bash</p>

<h1>run ssh daemon on homepc for local “dynamic” application-level port forwarding</h1>

<p>apple@homepc
➜  ssh -N -D 12171 apple@proxy-server &amp;</p>

<p>apple@homepc
➜  ssh -oProxyCommand=&lsquo;nc -x 127.0.0.1:12171 %h %p&rsquo; <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x61;&#112;&#112;&#x6c;&#101;&#64;&#x31;&#x30;&#46;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#53;">&#x61;&#112;&#x70;&#108;&#101;&#64;&#x31;&#x30;&#x2e;&#x30;&#46;&#x31;&#48;&#46;&#50;&#x35;</a></p>

<p>```</p>

<ul>
<li><p>方法E：类似于本地 ssh 代理的方式，可以在 proxy-server 上运行任何协议类型的代理，在 homepc 本地运行代理客户端连接 proxy-server 上的 proxy，在 ssh 的 ProxyCommand 指定为本地代理客户端的连接点即可。</p></li>
<li><p>方法F：利用 <a href="http://www.agroman.net/corkscrew/">corkscrew</a> ，<a href="https://packages.debian.org/source/sid/connect-proxy">connect-proxy</a>，<a href="https://github.com/rofl0r/proxychains-ng">proxychains</a> 等直接连接 proxy-server 上的代理。假定 proxy-server 上运行有 squid http 代理，代理使用用户名/密码这种基本验证方式。corkscrew 仅支持 http 代理，connect-proxy 和 proxychains 支持 http, socks4, socks5 代理。proxychains 还支持 shell 内所有流量都通过代理，提供了更过的功能，这里不展开叙述。只简单看一下通过它们使用 http 代理连接 ssh 的情况。</p></li>
</ul>


<p>``` bash</p>

<h1>corkscrew can specify authfile with pattern of username:password for http proxy authentication</h1>

<p>apple@homepc
➜  ssh -oProxyCommand=&lsquo;corkscrew proxy-server 3128 %h %p ~/.ssh/authfile&rsquo; <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#97;&#x70;&#112;&#x6c;&#x65;&#x40;&#49;&#x30;&#46;&#x30;&#46;&#x31;&#x30;&#x2e;&#50;&#53;">&#97;&#x70;&#112;&#x6c;&#x65;&#x40;&#49;&#48;&#46;&#48;&#x2e;&#x31;&#x30;&#46;&#50;&#x35;</a></p>

<h1>use connect-proxy</h1>

<p>apple@homepc
➜  ssh -oProxyCommand=&lsquo;connect -H apple@proxy-server:3128 %h %p&rsquo; <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#97;&#112;&#112;&#x6c;&#x65;&#x40;&#x31;&#48;&#46;&#48;&#46;&#x31;&#48;&#x2e;&#x32;&#53;">&#x61;&#112;&#x70;&#x6c;&#x65;&#64;&#x31;&#48;&#46;&#48;&#x2e;&#x31;&#x30;&#x2e;&#x32;&#x35;</a></p>

<h1>use proxychains</h1>

<h1>add &ldquo;http xxx.yyy.zzz.www 3128 apple apple&rdquo; to &ldquo;[ProxyList]&rdquo; node in proxychains config file</h1>

<h1>xxx.yyy.zzz.www is the WAN ip of proxy-server. proxychains doesn&rsquo;t support dns lookup for proxy server</h1>

<h1>more details: <a href="https://github.com/rofl0r/proxychains-ng/issues/25">https://github.com/rofl0r/proxychains-ng/issues/25</a></h1>

<p>apple@homepc
➜  proxychains4 ssh <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x61;&#112;&#x70;&#108;&#101;&#x40;&#49;&#48;&#46;&#48;&#46;&#x31;&#x30;&#46;&#x32;&#x35;">&#97;&#x70;&#x70;&#x6c;&#101;&#64;&#49;&#48;&#x2e;&#x30;&#46;&#49;&#48;&#46;&#x32;&#x35;</a></p>

<p>```</p>

<h3>ProxyCommand</h3>

<hr />

<p>关于 ProxyCommand 在此不多叙述，详情参考 <code>man ssh_config</code>。可以在 ~/.ssh/config 中配置 ProxyCommand，还可以根据不同的 host 配置不同的 ProxyCommand。</p>

<h3>原理分析</h3>

<hr />

<p>这些方法看起来有些眼花缭乱，但其实原理都很简单，除去登录到跳板机的情形，剩下场景的都是通过某种形式连接到代理服务器上的代理（或通过更多层的代理连接到代理服务器上的代理，形成一个代理链），由代理转发数据到目标服务器。</p>

<p>首先看方法C 的场景，参考<a href="http://backdrift.org/transparent-proxy-with-ssh">transparent-proxy-with-ssh</a></p>

<pre><code>    +--------+                  +--------------+                +---------------+
    | homepc |                  | proxy-server |                | target-server |
    |        | ===ssh=over=netcat=tunnel======================&gt; | 10.0.10.25    |
    +--------+                  +--------------+                +---------------+
</code></pre>

<p>该场景中，proxy-server 上实际运行有 <code>nc 10.0.10.25 22</code> 进程，该进程将会完成数据在 homepc 和 target-server 之间的转发。</p>

<p>方法D, E, F 中包含有明显的代理，以方法F 中的 corkscrew + squid http proxy 进行分析。</p>

<p>ssh 指定使用 ProxyCommand 之后，在建立连接时有这样一段关键代码：</p>

<p>``` c</p>

<p>// from openssh-5.9p1, sshconnect.c
int
ssh_connect(const char *host, struct sockaddr_storage * hostaddr,</p>

<pre><code>u_short port, int family, int connection_attempts, int *timeout_ms,
int want_keepalive, int needpriv, const char *proxy_command)
</code></pre>

<p>{</p>

<pre><code>...
/* If a proxy command is given, connect using it. */
    if (proxy_command != NULL)
        return ssh_proxy_connect(host, port, proxy_command);
...
</code></pre>

<p>}</p>

<p>```</p>

<p>在 ssh_proxy_connect 中会 fork 出子进程来执行 ProxyCommand 中的命令，同时会重定向子进程的标准输入和标准输出，子进程的标准输入重定向到 pin[0]，所以子进程会通过 pin[1] 获得父进程标准输出的内容；子进程的标准输出重定向到 pout[1]，所以写到子进程标准输出的内容可以在父进程通过读取 pout[0] 获得。</p>

<p>``` c</p>

<p>// from openssh-5.9p1, sshconnect.c
static int
ssh_proxy_connect(const char <em>host, u_short port, const char </em>proxy_command)
{</p>

<pre><code>...

/* Fork and execute the proxy command. */
if ((pid = fork()) == 0) {
    ...

    /* Redirect stdin and stdout. */
    close(pin[1]);
    if (pin[0] != 0) {
        if (dup2(pin[0], 0) &lt; 0)
            perror("dup2 stdin");
        close(pin[0]);
    }
    close(pout[0]);
    if (dup2(pout[1], 1) &lt; 0)
        perror("dup2 stdout");
    /* Cannot be 1 because pin allocated two descriptors. */
    close(pout[1]);

    /* Stderr is left as it is so that error messages get
       printed on the user's terminal. */
    argv[0] = shell;
    argv[1] = "-c";
    argv[2] = command_string;
    argv[3] = NULL;

    /* Execute the proxy command.  Note that we gave up any
       extra privileges above. */
    signal(SIGPIPE, SIG_DFL);
    execv(argv[0], argv);
    perror(argv[0]);
    exit(1);
}
...
/* Close child side of the descriptors. */
close(pin[0]);
close(pout[1]);

/* Set the connection file descriptors. */
packet_set_connection(pout[0], pin[1]);

...
</code></pre>

<p>}</p>

<p>```</p>

<pre><code> +----------+             +---------------+               +----------+              +---------------+
 | terminal |  --------&gt;  | parent stdout |  ----------&gt;  |  pin[0]  |  ---------&gt;  |  child stdin  |
 |  input   |             |    pin[1]     |     read      |          |   redirect   |               |
 +----------+             +---------------+               +----------+              +---------------+

 +----------+             +---------------+               +----------+              +---------------+
 | terminal |  &lt;--------  | parent stdin  |  &lt;----------  |  pout[1] |  &lt;---------  |  child stdout |
 | display  |             |    pout[0]    |     read      |          |   redirect   |               |
 +----------+             +---------------+               +----------+              +---------------+
</code></pre>

<p>上图描述了调用 ProxyCommand 时 ssh 客户端数据的流动情况，在我们的应用场景中，父进程对应 ssh 客户端进程，子进程运行 corkscrew。corkscrew 的实现很简单，它与代理服务器创建 tcp 连接，然后进入一个主循环，通过 select(2) 处理文件事件。
（注意 corkscrew 将与代理服务器协商的代码也写在主循环中，通过 setup 标志来确定处于建立连接后的协商阶段还是已经建立好到代理的连接，协商部分的代码可以抽离出来，类似的 connect-proxy 就是抽离出协商阶段和稳定连接阶段。下边分析的主循环略过协商阶段的代码。），这样处理文件读写事件的代码就非常简单：</p>

<p>``` c</p>

<p>// from corkscrew2.0, corkscrew.c
for(;;) {</p>

<pre><code>FD_ZERO(&amp;sfd);
FD_ZERO(&amp;rfd);

FD_SET(csock, &amp;rfd);
FD_SET(0, &amp;rfd);

tv.tv_sec = 5;
tv.tv_usec = 0;

if(select(csock+1,&amp;rfd,&amp;sfd,NULL,&amp;tv) == -1) break;

if (FD_ISSET(csock, &amp;rfd)) {
    len = read(csock, buffer, sizeof(buffer));
    if (len&lt;=0) break;
    len = write(1, buffer, len);
    if (len&lt;=0) break;
}

if (FD_ISSET(0, &amp;rfd)) {
    len = read(0, buffer, sizeof(buffer));
    if (len&lt;=0) break;
    len = write(csock, buffer, len);
    if (len&lt;=0) break;
}
</code></pre>

<p>}</p>

<p>```</p>

<p>corkscrew 的处理逻辑很清楚，从标准输入读取的数据，write 到 csock 中；从 csock 读取的数据，write 到标准输出。与 ssh 客户端结合起来，就可以得到下边的一张图：</p>

<pre><code> +--------------+             +------------+               +-----------------+          +---------+
 | child stdin  |  --------&gt;  | corkscrew  |  ----------&gt;  | csock           |  -----&gt;  |  proxy  |
 | corkscrew    |    read     |            |     write     | conn with proxy |          |         |
 +--------------+             +------------+               +-----------------+          +---------+

 +--------------+             +------------+               +-----------------+          +---------+
 | child stdout |  &lt;--------  | corkscrew  |  &lt;----------  | csock           |  &lt;-----  |  proxy  |
 | corkscrew    |    write    |            |     read      | conn with proxy |          |         |
 +--------------+             +------------+               +-----------------+          +---------+
</code></pre>

<p>从代理到目标服务器的数据收发与上述实现类似，只是 socket 有所不同，不再按照不同代理具体分析。使用不同的代理形式，只是在代理协商阶段有所不同，当稳定连接后，代理的工作就是不停的转发数据了。从数据的发送接收角度，加入代理后不影响 ssh 客户端和服务器之间传输数据的内容和顺序，因而可以将代理看做是透明的，就好像 ssh 客户端直接连接到目标服务器一样。</p>

<h3>问答</h3>

<p>TODO</p>

<ol>
<li>使用代理会不会存在安全问题？例如 <a href="http://www.unixwiz.net/techtips/ssh-agent-forwarding.html#sec">Security Issues With Key Agents</a> 提到的安全问题。</li>
<li>我使用 <a href="https://mosh.mit.edu">mosh</a>，这些方法是否可以使用？</li>
<li>如果我使用公私钥登录的方式，代理服务器上需要进行哪些操作？</li>
</ol>


<h3>参考链接</h3>

<ol>
<li><a href="http://backdrift.org/transparent-proxy-with-ssh">Using SSH ProxyCommand to Tunnel Connections</a></li>
<li><a href="http://daniel.haxx.se/docs/sshproxy.html">SSH Through or Over Proxy</a></li>
<li><a href="http://www.agroman.net/corkscrew/">Corkscrew</a></li>
<li><a href="http://en.wikibooks.org/wiki/OpenSSH/Cookbook/Proxies_and_Jump_Hosts">OpenSSH/Cookbook/Proxies and Jump Hosts</a></li>
<li><a href="http://www.unixwiz.net/techtips/ssh-agent-forwarding.html">An Illustrated Guide to SSH Agent Forwarding</a></li>
<li><a href="http://www.zeitoun.net/articles/ssh-through-http-proxy/start">SSH through HTTP proxy</a></li>
<li><a href="http://www.lainme.com/doku.php/blog/2011/01/%E9%80%8F%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5ssh">透过代理连接SSH</a></li>
</ol>

]]></content>
  </entry>
  
</feed>

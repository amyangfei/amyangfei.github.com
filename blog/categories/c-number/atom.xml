<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C# | Amyangfei's Blog]]></title>
  <link href="http://amyangfei.me/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://amyangfei.me/"/>
  <updated>2014-01-25T14:27:25+08:00</updated>
  <id>http://amyangfei.me/</id>
  <author>
    <name><![CDATA[amyangfei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Use Named Pipes to Communicate Between Processes]]></title>
    <link href="http://amyangfei.me/2012/03/21/namedpipe-communication/"/>
    <updated>2012-03-21T00:00:00+08:00</updated>
    <id>http://amyangfei.me/2012/03/21/namedpipe-communication</id>
    <content type="html"><![CDATA[<p>最近几天生活突然变得异常纠结，许多乱乱的事情搅在了一起，真希望可以快到斩乱麻似的解决问题，可到头来每一件事情都还是要小心翼翼地处理。</p>

<p>犹豫了好久终于决定向创新工场辞职，实习毕设兼顾的日子有些让我心力交瘁。昨天搭博客还出了问题，虽是粗心大意，可确实做了不正确的事，满心愧疚。毕设要和研究生学长合作完成，学长在没和我有过任何商量的情况下选择了.NET的开发平台，一来我对微软的产品不感兴趣，没有过什么写C#的经验，二来需要继续使用的原有系统是C++开发的，就不得不考虑在C#中调用C++的方法和类。百味俱陈，无限纠结，心情一落千丈。</p>

<p>虽说如此，毕设还要做。现有的需求是将一个由C++实现的SQL语法，语义解析器迁移到C#工程中进一步进行开发。网上查了一些，有利用DllImport，有托管C++包装现有的DLL供C#调用的方法，还有一些包装C++的方法，简单看了一下一头雾水，考虑到项目的特殊性，最后没有选择C#调用C++的方式，而是采取了进程间通信的方法。</p>

<!-- more -->


<p>具体实现是在C++的SQL语义解析器端开启一个服务进程，等待客户端的连接请求。每次C#端发起连接，在C++端开启一个线程，进行相应的语法，语义解析最后按定义好的数据结构给客户端返回结果。进程间通信使用了Named Pipe。我在<a href="http://msdn.microsoft.com/en-us/library/bb762927.aspx" target="_blank">MSDN</a>官方文档上看到了一个很详细的使用方法，基本是按照官方文档实现的。</p>

<p>这里列出我觉得比较重要的部分，在这里有一份MSDN>提供的完整的<a href="http://msdn.microsoft.com/en-us/library/aa365588(VS.85).aspx" target="_blank">C++ Server</a>的代码</p>

<h3>C++ Server</h3>

<p>``` c++
hPipe = CreateNamedPipe(lpszPipename, PIPE_ACCESS_DUPLEX,</p>

<pre><code>PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, 0, NULL);
</code></pre>

<p>fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);</p>

<p>if (fConnected) {</p>

<pre><code>printf("Client connected, creating a processing thread.\n"); 
// Create a thread for this client. 
hThread = CreateThread(NULL, 0, InstanceThread, (LPVOID) hPipe, 0, &amp;dwThreadId);
if (hThread == NULL) {
    _tprintf(TEXT("CreateThread failed, GLE=%d.\n"), GetLastError()); 
    return -1;
}
else CloseHandle(hThread); 
</code></pre>

<p>}
else</p>

<pre><code>CloseHandle(hPipe); 
</code></pre>

<p>}</p>

<p>DWORD WINAPI InstanceThread(LPVOID lpvParam) {
   HANDLE hHeap      = GetProcessHeap();
   TCHAR<em> pchRequest = (TCHAR</em>)HeapAlloc(hHeap, 0, BUFSIZE<em>sizeof(TCHAR));
   TCHAR</em> pchReply   = (TCHAR<em>)HeapAlloc(hHeap, 0, BUFSIZE</em>sizeof(TCHAR));
   DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0;
   BOOL fSuccess = FALSE;
   HANDLE hPipe  = NULL;
   bool destoryThread = false;</p>

<p>   printf(&ldquo;InstanceThread created, receiving and processing messages.\n&rdquo;);</p>

<p>   hPipe = (HANDLE) lpvParam;
   while (!destoryThread) {</p>

<pre><code>    while(true) {
       fSuccess = ReadFile(hPipe, pchRequest, BUFSIZE * sizeof(TCHAR), &amp;cbBytesRead, NULL);
       if (!fSuccess || cbBytesRead == 0) {
           destoryThread = true;
           break;
       }
       pchRequest[cbBytesRead] = '\0';
       strcpy(pchReply, getParsedSql(pchRequest)); //getParsedSql是调用的接口函数
       cbReplyBytes = (lstrlen(pchReply))*sizeof(TCHAR);
       pchReply[cbReplyBytes] = '\n';
       pchReply[cbReplyBytes+1] = '\0';
       cbReplyBytes += 1;

       fSuccess = WriteFile(hPipe, pchReply, cbReplyBytes, &amp;cbWritten, NULL);//send back to client

       cout &lt;&lt; "Result after sql parse: " &lt;&lt; pchReply &lt;&lt; endl;
       if (!fSuccess || cbReplyBytes != cbWritten) {
           destoryThread = true;
           break;
       }
   }
</code></pre>

<p>  }</p>

<pre><code>//do some clean work
</code></pre>

<p>   printf(&ldquo;InstanceThread exitting.\n&rdquo;);
   return 1;
}
```</p>

<h3>C# Client</h3>

<p>``` c#
static void Main(string[] args) {</p>

<pre><code>NamedPipeClientStream pipeClient = new NamedPipeClientStream(".", "testpipe", 
    PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.Impersonation);

Console.WriteLine("Connecting to server...\n");
pipeClient.Connect(2000);

StreamWriter sw = new StreamWriter(pipeClient);
StreamReader sr = new StreamReader(pipeClient);
sw.AutoFlush = true;
while (true) {
    string outStr = Console.ReadLine();
    sw.WriteLine(outStr);
    if (outStr.Equals("quit")) {
        break;
    }
    Console.WriteLine("get back from server:" + sr.ReadLine());
}
sw.Close();
sr.Close();
pipeClient.Close();
// Give the client process some time to display results before exiting.
Thread.Sleep(4000);
</code></pre>

<p>}
```</p>

<p>今天写代码时候遇到一个bug，就是在服务器接收pchRequest处理得到pchReply后向客户端发送总会发生阻塞，调了很久找到bug的出处是处理后的pchReply末尾没有换行符，导致在C#客户端使用ReadLine()接收一直处于阻塞状态。于是在代码中有了下面的一段。</p>

<p><code>c++
cbReplyBytes = (lstrlen(pchReply))*sizeof(TCHAR);
pchReply[cbReplyBytes] = '\n';
pchReply[cbReplyBytes+1] = '\0';
cbReplyBytes += 1;
</code></p>
]]></content>
  </entry>
  
</feed>
